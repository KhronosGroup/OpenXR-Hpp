//## Copyright (c) 2017-2019 The Khronos Group Inc.
//## Copyright (c) 2019 Collabora, Ltd.
//##
//## Licensed under the Apache License, Version 2.0 (the "License");
//## you may not use this file except in compliance with the License.
//## You may obtain a copy of the License at
//##
//##     http://www.apache.org/licenses/LICENSE-2.0
//##
//## Unless required by applicable law or agreed to in writing, software
//## distributed under the License is distributed on an "AS IS" BASIS,
//## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//## See the License for the specific language governing permissions and
//## limitations under the License.
//##
//## ---- Exceptions to the Apache 2.0 License: ----
//##
//## As an exception, if you use this Software to generate code and portions of
//## this Software are embedded into the generated code as a result, you may
//## redistribute such product without providing attribution as would otherwise
//## be required by Sections 4(a), 4(b) and 4(d) of the License.
//##
//## In addition, if you combine or link code generated by this Software with
//## software that is licensed under the GPLv2 or the LGPL v2.0 or 2.1
//## ("`Combined Software`") and if a court of competent jurisdiction determines
//## that the patent provision (Section 3), the indemnity provision (Section 9)
//## or other Section of the License conflicts with the conditions of the
//## applicable GPL or LGPL license, you may retroactively and prospectively
//## choose to deem waived or otherwise exclude such Section(s) of the License,
//## but only in their entirety and only with respect to the Combined Software.

//# include('file_header.hpp')
/**
 * @file
 * @brief C++ exceptions for the OpenXR error result codes.
 *
 * @see OPENXR_HPP_NO_EXCEPTIONS
 */


/*!
 * @def OPENXR_HPP_NO_EXCEPTIONS
 * @brief Define in order to disable throwing of exceptions from C++ projections of OpenXR methods.
 *
 * Enhanced mode calls can throw on receiving an error code, allowing only success codes to come back through the normal path.
 * Some can even omit the Result return value entirely, if there are no particularly useful success codes besides Result::Success.
 *
 * @see OPENXR_HPP_DISABLE_ENHANCED_MODE
 * @see openxr_exceptions.hpp
 *
 * @ingroup config
 */

#if !defined(OPENXR_HPP_NO_EXCEPTIONS)

#include "openxr_enums.hpp"

//# include('define_inline_constexpr.hpp') without context
//# include('define_namespace.hpp') without context
//# include('define_namespace_string.hpp') without context

#include <stdexcept>
#include <system_error>

namespace OPENXR_HPP_NAMESPACE {

//! Implementation details
namespace impl {
#if defined(_MSC_VER) && (_MSC_VER == 1800)
#define noexcept _NOEXCEPT
#endif

class ErrorCategoryImpl : public std::error_category {
   public:
    virtual const char* name() const noexcept override { return OPENXR_HPP_NAMESPACE_STRING "::Result"; }
    virtual std::string message(int ev) const override { return to_string(static_cast<Result>(ev)); }
};

#if defined(_MSC_VER) && (_MSC_VER == 1800)
#undef noexcept
#endif

OPENXR_HPP_INLINE const std::error_category& errorCategory() {
    static impl::ErrorCategoryImpl instance;
    return instance;
}

OPENXR_HPP_INLINE std::error_code make_error_code(Result e) { return std::error_code(static_cast<int>(e), errorCategory()); }

OPENXR_HPP_INLINE std::error_condition make_error_condition(Result e) {
    return std::error_condition(static_cast<int>(e), errorCategory());
}

#if defined(_MSC_VER) && (_MSC_VER == 1800)
#define noexcept _NOEXCEPT
#endif
}  // namespace impl

//! OpenXR exceptions
namespace exceptions {
/*!
 * @defgroup exceptions Exceptions
 *
 * @{
 */
/*!
 * @defgroup base_exceptions Exception base classes
 * @{
 */
//! @brief Base class for all OpenXR exceptions.
//!
//! Only used for catching all OpenXR exceptions.
class Error {
   public:
    virtual ~Error() = default;

    virtual const char* what() const noexcept = 0;
};

//! @brief OpenXR logic error base exception class.
//!
//! Derives from both Error and std::logic_error for flexibility in catching.
class LogicError : public Error, public std::logic_error {
   public:
    explicit LogicError(const std::string& what) : Error(), std::logic_error(what) {}
    explicit LogicError(char const* what) : Error(), std::logic_error(what) {}
    virtual ~LogicError() = default;

    virtual const char* what() const noexcept { return std::logic_error::what(); }
};

//! @brief OpenXR system error exception class - may be derived from or thrown directly.
//!
//! Derives from both Error and std::system_error for flexibility in catching.
class SystemError : public Error, public std::system_error {
   public:
    SystemError(std::error_code ec) : Error(), std::system_error(ec) {}
    SystemError(std::error_code ec, std::string const& what) : Error(), std::system_error(ec, what) {}
    SystemError(std::error_code ec, char const* what) : Error(), std::system_error(ec, what) {}
    SystemError(int ev, std::error_category const& ecat) : Error(), std::system_error(ev, ecat) {}
    SystemError(int ev, std::error_category const& ecat, std::string const& what) : Error(), std::system_error(ev, ecat, what) {}
    SystemError(int ev, std::error_category const& ecat, char const* what) : Error(), std::system_error(ev, ecat, what) {}
    virtual ~SystemError() = default;

    virtual const char* what() const noexcept { return std::system_error::what(); }
};

// end of base_exceptions
//! @}
#if defined(_MSC_VER) && (_MSC_VER == 1800)
#undef noexcept
#endif

/*!
 * @defgroup result_exceptions Result-specific exceptions
 * @{
 */
//## @todo identify which errors would be considered LogicError and subclass that instead. Add to XML?
//# for val in result_enum.values if "XR_ERROR" in val.name
/*{ protect_begin(val, enum) }*/
//#     set valname = create_enum_value(val.name, 'XrResult')
//#    set classname = create_enum_exception(val.name)
//! @brief Exception class for the Result::/*{valname}*/ aka /*{val.name}*/ result code.
class /*{classname}*/ : public SystemError {
   public:
    /*{classname}*/ (std::string const& message)
        : SystemError(impl::make_error_code(Result::/*{valname}*/), message){}

    /*{classname}*/ (char const* message)
        : SystemError(impl::make_error_code(Result::/*{valname}*/), message) {}
};
/*{ protect_end(val, enum) }*/
//# endfor

// end of result_exceptions
//! @}

/*!
 * @brief Throws the best exception for a result code.
 *
 * Takes a result code and a message (usually the method triggering the exception) and throws the most-specific exception available
 * for that result code. As a fallback, it will throw a SystemError directly.
 */
OPENXR_HPP_INLINE void throwResultException(Result result, char const* message) {
    switch (result) {
        //# for val in result_enum.values
        /*{ protect_begin(val, enum) }*/
        //#     set valname = create_enum_value(val.name, 'XrResult')
        case Result::/*{valname}*/:
            //# if "XR_ERROR" in val.name
            //#     set classname = create_enum_exception(val.name)
            throw /*{classname}*/ (message);
            //# else
            // Not actually an error!
            throw SystemError(impl::make_error_code(result));
            //# endif
            /*{ protect_end(val, enum) }*/

            //# endfor

        default:
            throw SystemError(impl::make_error_code(result));
    }
}
//! @}
}  // namespace exceptions
}  // namespace OPENXR_HPP_NAMESPACE

#if !defined(OPENXR_HPP_DOXYGEN)
namespace std {
template <>
struct is_error_code_enum<OPENXR_HPP_NAMESPACE::Result> : public true_type {};
}  // namespace std
#endif  // !defined(OPENXR_HPP_DOXYGEN)
#endif  // !defined(OPENXR_HPP_NO_EXCEPTIONS)

//# include('file_footer.hpp')
