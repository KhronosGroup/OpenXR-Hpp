//## Copyright (c) 2017-2019 The Khronos Group Inc.
//## Copyright (c) 2019 Collabora, Ltd.
//##
//## Licensed under the Apache License, Version 2.0 (the "License");
//## you may not use this file except in compliance with the License.
//## You may obtain a copy of the License at
//##
//##     http://www.apache.org/licenses/LICENSE-2.0
//##
//## Unless required by applicable law or agreed to in writing, software
//## distributed under the License is distributed on an "AS IS" BASIS,
//## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//## See the License for the specific language governing permissions and
//## limitations under the License.
//##
//## ---- Exceptions to the Apache 2.0 License: ----
//##
//## As an exception, if you use this Software to generate code and portions of
//## this Software are embedded into the generated code as a result, you may
//## redistribute such product without providing attribution as would otherwise
//## be required by Sections 4(a), 4(b) and 4(d) of the License.
//##
//## In addition, if you combine or link code generated by this Software with
//## software that is licensed under the GPLv2 or the LGPL v2.0 or 2.1
//## ("`Combined Software`") and if a court of competent jurisdiction determines
//## that the patent provision (Section 3), the indemnity provision (Section 9)
//## or other Section of the License conflicts with the conditions of the
//## applicable GPL or LGPL license, you may retroactively and prospectively
//## choose to deem waived or otherwise exclude such Section(s) of the License,
//## but only in their entirety and only with respect to the Combined Software.

//# include('file_header.hpp')

/**
 * @file
 * @brief Forward declarations of OpenXR handle wrapper types.
 *
 * @see openxr_handles.hpp
 * @ingroup handles
 */

#include "openxr_enums.hpp"

//# include('define_namespace.hpp') without context
//# include('nongenerated_unique.hpp') without context

namespace OPENXR_HPP_NAMESPACE {

namespace traits {
    //! Type trait associating an ObjectType enum value with its C++ type.
    template <ObjectType o>
    struct cpp_type_from_object_type_enum;
}  // namespace traits

// forward declarations

class DispatchLoaderStatic;
class DispatchLoaderDynamic;

// FIXME a hack to get this working, since I don't know how to appropriately force the code to not project the
// XrSpaceUserIdFB name, and I don't want to make a openxr_spaceuseridfb.hpp file just for this.
using SpaceUserIdFB = XrSpaceUserIdFB;

//# for handle in gen.api_handles
//## Note this won't actually find anything until automatic_source_generator.py is modified
//## to actually store a value under "alias" for handles, but...
//#     if handle.alias
using /*{ project_type_name(handle.name) }*/ = /*{ project_type_name(handle.alias) }*/;
//#     else
class /*{ project_type_name(handle.name) }*/;
//#     endif
//# endfor

/*!
 * @defgroup handles Handle types
 * @brief Wrappers for OpenXR handle types, with associated functions mapped as methods.
 * @ingroup wrappers
 */
/*!
 * @defgroup unique_handle_aliases Aliases for UniqueHandle types
 * @brief Convenience names for specializations of UniqueHandle<>
 * @ingroup handles
 */

#ifndef OPENXR_HPP_NO_SMART_HANDLE
#ifndef OPENXR_HPP_DOXYGEN
namespace traits {
//# for handle in gen.api_handles
//#     set shortname = project_type_name(handle.name)
template <typename Dispatch>
class UniqueHandleTraits</*{shortname}*/, Dispatch> {
   public:
    using deleter = ObjectDestroy<Dispatch>;
};
//# endfor

} //namespace traits
#endif  // !OPENXR_HPP_DOXYGEN

//! @addtogroup unique_handle_aliases
//! @{

//## TODO use DispatchLoaderDynamic for extension-provided handles!
//# for handle in gen.api_handles
//#     set shortname = project_type_name(handle.name)
//! Shorthand name for unique handles of type /*{shortname}*/, using a static dispatch.
using /*{'Unique' + shortname}*/ = UniqueHandle</*{shortname}*/, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type /*{shortname}*/, using a dynamic dispatch.
using /*{'UniqueDynamic' + shortname}*/ = UniqueHandle</*{shortname}*/, DispatchLoaderDynamic>;
//# endfor
//! @}
#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#ifndef OPENXR_HPP_DOXYGEN
namespace traits {
// Explicit specializations of cpp_type_from_object_type_enum
//# for handle in gen.api_handles
//#     set shortname = project_type_name(handle.name)
/*{protect_begin(handle)}*/
template <>
struct cpp_type_from_object_type_enum<ObjectType::/*{shortname}*/> {
    using type = /*{shortname}*/;
};
/*{protect_end(handle)}*/
//# endfor
} // namespace traits
#endif  // !OPENXR_HPP_DOXYGEN

}  // namespace OPENXR_HPP_NAMESPACE

//# include('file_footer.hpp')
