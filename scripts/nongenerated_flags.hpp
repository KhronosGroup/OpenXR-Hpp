//## Copyright (c) 2017-2019 The Khronos Group Inc.
//## Copyright (c) 2019 Collabora, Ltd.
//##
//## Licensed under the Apache License, Version 2.0 (the "License");
//## you may not use this file except in compliance with the License.
//## You may obtain a copy of the License at
//##
//##     http://www.apache.org/licenses/LICENSE-2.0
//##
//## Unless required by applicable law or agreed to in writing, software
//## distributed under the License is distributed on an "AS IS" BASIS,
//## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//## See the License for the specific language governing permissions and
//## limitations under the License.
//##
//## ---- Exceptions to the Apache 2.0 License: ----
//##
//## As an exception, if you use this Software to generate code and portions of
//## this Software are embedded into the generated code as a result, you may
//## redistribute such product without providing attribution as would otherwise
//## be required by Sections 4(a), 4(b) and 4(d) of the License.
//##
//## In addition, if you combine or link code generated by this Software with
//## software that is licensed under the GPLv2 or the LGPL v2.0 or 2.1
//## ("`Combined Software`") and if a court of competent jurisdiction determines
//## that the patent provision (Section 3), the indemnity provision (Section 9)
//## or other Section of the License conflicts with the conditions of the
//## applicable GPL or LGPL license, you may retroactively and prospectively
//## choose to deem waived or otherwise exclude such Section(s) of the License,
//## but only in their entirety and only with respect to the Combined Software.


namespace OPENXR_HPP_NAMESPACE {

/**
 * @brief Template type for bit flag projection
 *
 * @tparam BitType The projected enum that contains the bits
 * @tparam MaskType The type of the combined flags, typically the default, XrFlags64.
 */
template <typename BitType, typename MaskType = XrFlags64>
class Flags {
   public:
    //! Default constructor
    OPENXR_HPP_CONSTEXPR Flags() : m_mask(0) {}

    //! Implicit constructor from a single bit
    Flags(BitType bit) : m_mask(static_cast<MaskType>(bit)) {}

    //! Copy constructor
    Flags(Flags const &rhs) = default;

    //! Copy assignment
    Flags &operator=(Flags const &rhs) = default;

    //! Explicit constructor from flags value
    explicit Flags(MaskType flags) : m_mask(flags) {}

    //! OR update operator - commonly used for combining flags
    Flags &operator|=(Flags const &rhs) {
        m_mask |= rhs.m_mask;
        return *this;
    }

    //! AND update operator
    Flags &operator&=(Flags const &rhs) {
        m_mask &= rhs.m_mask;
        return *this;
    }

    //! XOR update operator
    Flags &operator^=(Flags const &rhs) {
        m_mask ^= rhs.m_mask;
        return *this;
    }

    //! OR operator, often used for combining flags.
    Flags operator|(Flags const &rhs) const {
        Flags result(*this);
        result |= rhs;
        return result;
    }

    //! AND operator, often used for testing the value of certain bits.
    Flags operator&(Flags const &rhs) const {
        Flags result(*this);
        result &= rhs;
        return result;
    }

    //! XOR operator
    Flags operator^(Flags const &rhs) const {
        Flags result(*this);
        result ^= rhs;
        return result;
    }

    //! Unary negation: true if all bits were false.
    bool operator!() const { return !m_mask; }

    //! Bitwise negation (complement) operator
    Flags operator~() const {
        Flags result(*this);
        result.m_mask ^= static_cast<MaskType>(BitType::AllBits);
        return result;
    }

    //! Accessor for contained value
    MaskType get() const noexcept { return m_mask; }

    //! Equality comparison
    bool operator==(Flags const &rhs) const { return m_mask == rhs.m_mask; }

    //! Inequality comparison
    bool operator!=(Flags const &rhs) const { return m_mask != rhs.m_mask; }

    //! Equality comparison, mainly intended for compare to 0
    bool operator==(int rhs) const { return m_mask == static_cast<MaskType>(rhs); }

    //! Inequality comparison, mainly intended for compare to 0
    bool operator!=(int rhs) const { return m_mask != static_cast<MaskType>(rhs); }

    //! Explicit bool conversion: true if any bits are true.
    explicit operator bool() const { return !!m_mask; }

    //! Explicit conversion operator to the underlying mask type.
    explicit operator MaskType() const { return m_mask; }

   private:
    MaskType m_mask;
};

/**
 * @brief Bitwise OR between a Flags<> value and a single bit.
 *
 * @tparam BitType The projected bit type
 * @param bit The single bit
 * @param flags The Flags<> value
 * @return Flags<BitType>
 *
 * @relates Flags
 */
template <typename BitType, typename MaskType>
Flags<BitType, MaskType> operator|(BitType bit, Flags<BitType, MaskType> const &flags) {
    return flags | bit;
}

/**
 * @brief Bitwise AND between a Flags<> value and a single bit.
 *
 * @tparam BitType The projected bit type
 * @param bit The single bit
 * @param flags The Flags<> value
 * @return Flags<BitType>
 *
 * @relates Flags
 */
template <typename BitType, typename MaskType>
Flags<BitType, MaskType> operator&(BitType bit, Flags<BitType, MaskType> const &flags) {
    return flags & bit;
}

/**
 * @brief Bitwise XOR between a Flags<> value and a single bit.
 *
 * @tparam BitType The projected bit type
 * @param bit The single bit
 * @param flags The Flags<> value
 * @return Flags<BitType>
 *
 * @relates Flags
 */
template <typename BitType, typename MaskType>
Flags<BitType, MaskType> operator^(BitType bit, Flags<BitType, MaskType> const &flags) {
    return flags ^ bit;
}

}  // namespace OPENXR_HPP_NAMESPACE
