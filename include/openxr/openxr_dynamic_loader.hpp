/*
** Copyright (c) 2017-2019 The Khronos Group Inc.
** Copyright (c) 2019 Collabora, Ltd.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
** ---- Exceptions to the Apache 2.0 License: ----
**
** As an exception, if you use this Software to generate code and portions of
** this Software are embedded into the generated code as a result, you may
** redistribute such product without providing attribution as would otherwise
** be required by Sections 4(a), 4(b) and 4(d) of the License.
**
** In addition, if you combine or link code generated by this Software with
** software that is licensed under the GPLv2 or the LGPL v2.0 or 2.1
** ("`Combined Software`") and if a court of competent jurisdiction determines
** that the patent provision (Section 3), the indemnity provision (Section 9)
** or other Section of the License conflicts with the conditions of the
** applicable GPL or LGPL license, you may retroactively and prospectively
** choose to deem waived or otherwise exclude such Section(s) of the License,
** but only in their entirety and only with respect to the Combined Software.
**
*/

#include <openxr/openxr.hpp>

#if defined(__linux__)
#include <dlfcn.h>
#endif
#if defined(_WIN32)
#include <windows.h>
#endif

namespace OPENXR_HPP_NAMESPACE {

/*!
* @brief Helper class to explicitly link against the OpenXR library.
*
* This class can be used to initialize a DispatchLoaderDynamic after getting the xrGetInstanceProcAddr function.
*/
class DynamicLoader {
public:
    DynamicLoader() {
#if defined(__linux__)
        m_library = dlopen("libopenxr_loader.so.1", RTLD_NOW | RTLD_LOCAL);
#elif defined(_WIN32)
        m_library = LoadLibrary(TEXT("openxr_loader.dll"));
#endif

#ifndef OPENXR_HPP_NO_EXCEPTIONS
        if (!m_library) {
            throw exceptions::InitializationFailedError("Failed to load vulkan library.");
        }
#endif
    }

    DynamicLoader(DynamicLoader const&) = delete;
    DynamicLoader(DynamicLoader&& other) : m_library(other.m_library) {
        other.m_library = nullptr;
    }

    DynamicLoader& operator=(DynamicLoader const&) = delete;
    DynamicLoader& operator=(DynamicLoader&& other) {
        std::swap(m_library, other.m_library);
        return *this;
    }

    ~DynamicLoader() noexcept {
        if (m_library) {
#if defined(__linux__)
            dlclose(m_library);
#elif defined(_WIN32)
            FreeLibrary(m_library);
#endif
        }
    }

    template <typename T>
    T getProcAddress(const char* function) const noexcept {
#if defined(__linux__)
        return (T)dlsym(m_library, function);
#elif defined(_WIN32)
        return (T)GetProcAddress(m_library, function);
#endif
    }

    bool success() const noexcept { return m_library; }

private:
#if defined(__linux__)
    void* m_library = nullptr;
#elif defined(_WIN32)
    HMODULE m_library = nullptr;
#else
#error unsupported platform
#endif
};

}
